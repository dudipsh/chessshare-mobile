import 'package:dartchess/dartchess.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../../../core/api/review_api_service.dart';
import '../../../core/database/local_database.dart';
import '../../../core/services/audio_service.dart';
import '../../../core/widgets/board_settings_sheet.dart';
import '../../auth/providers/auth_provider.dart';
import '../models/analyzed_move.dart';
import '../models/chess_game.dart';
import '../models/game_puzzle.dart';
import '../providers/exploration_mode_provider.dart';
import '../providers/game_review_provider.dart';
import 'game_review/accuracy_summary.dart';
import 'game_review/action_buttons.dart';
import 'game_review/analyzing_view.dart';
import 'game_review/exploration_bar.dart';
import 'game_review/move_info_panel.dart';
import 'game_review/move_strip.dart';
import 'game_review/navigation_controls.dart';
import 'game_review/review_chessboard.dart';
import 'game_review/review_error_view.dart';
import 'game_review/review_move_marker.dart';
import 'play_vs_stockfish_screen.dart';
import 'practice_puzzles_screen.dart';

class GameReviewScreen extends ConsumerStatefulWidget {
  final ChessGame game;

  const GameReviewScreen({super.key, required this.game});

  @override
  ConsumerState<GameReviewScreen> createState() => _GameReviewScreenState();
}

class _GameReviewScreenState extends ConsumerState<GameReviewScreen> {
  late String _userId;
  Side _orientation = Side.white;
  bool _isPlaying = false;
  bool _isGeneratingPuzzles = false;
  bool _wasAnalyzing = false;
  bool _hasAutoGeneratedPuzzles = false;

  @override
  void initState() {
    super.initState();
    _orientation = widget.game.playerColor == 'white' ? Side.white : Side.black;

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _userId = ref.read(authProvider).profile?.id ?? '';
      if (_userId.isNotEmpty) {
        ref.read(gameReviewProvider(_userId).notifier).loadReview(widget.game);
      }
    });
  }

  @override
  void dispose() {
    _stopPlayback();
    super.dispose();
  }

  void _togglePlayback() {
    if (_isPlaying) {
      _stopPlayback();
    } else {
      _startPlayback();
    }
  }

  void _startPlayback() {
    final state = ref.read(gameReviewProvider(_userId));
    if (state.review == null) return;

    // If at end, go to start first
    if (state.currentMoveIndex >= state.review!.moves.length) {
      ref.read(gameReviewProvider(_userId).notifier).goToStart();
    }

    setState(() => _isPlaying = true);
    _playNextMove();
  }

  void _stopPlayback() {
    setState(() => _isPlaying = false);
  }

  void _playNextMove() {
    if (!_isPlaying || !mounted) return;

    final state = ref.read(gameReviewProvider(_userId));
    if (state.review == null) {
      _stopPlayback();
      return;
    }

    final totalMoves = state.review!.moves.length;
    if (state.currentMoveIndex >= totalMoves) {
      _stopPlayback();
      return;
    }

    // Play next move
    ref.read(gameReviewProvider(_userId).notifier).nextMove();
    _playSoundForMoveIndex(state.currentMoveIndex + 1);

    // Schedule next move
    Future.delayed(const Duration(milliseconds: 800), () {
      if (_isPlaying && mounted) {
        _playNextMove();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final userId = ref.watch(authProvider).profile?.id ?? '';
    if (userId.isEmpty) {
      return const Scaffold(
        body: Center(child: Text('Please sign in to review games')),
      );
    }

    final state = ref.watch(gameReviewProvider(userId));
    final explorationState = ref.watch(explorationModeProvider);

    // Auto-generate puzzles when analysis completes
    if (_wasAnalyzing && !state.isAnalyzing && state.review != null && !_hasAutoGeneratedPuzzles) {
      _hasAutoGeneratedPuzzles = true;
      // Start generating puzzles in background
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted && _getMistakesCount(state) > 0) {
          _autoGeneratePuzzles(state);
        }
      });
    }
    _wasAnalyzing = state.isAnalyzing;

    // Sync exploration position with game review when not exploring
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!explorationState.isExploring && state.review != null) {
        ref.read(explorationModeProvider.notifier).setPosition(
          state.fen,
          state.currentMoveIndex,
        );
      }
    });

    final isDark = Theme.of(context).brightness == Brightness.dark;
    final screenWidth = MediaQuery.of(context).size.width;
    final boardSize = screenWidth - 16;

    return Scaffold(
      appBar: _buildAppBar(context, state),
      body: _buildBody(state, explorationState, boardSize, isDark),
    );
  }

  AppBar _buildAppBar(BuildContext context, GameReviewState state) {
    final explorationState = ref.watch(explorationModeProvider);
    final evalCp = explorationState.isExploring
        ? explorationState.evalCp
        : state.currentMove?.evalAfter;
    final isDark = Theme.of(context).brightness == Brightness.dark;

    return AppBar(
      title: Row(
        children: [
          _buildEvalBadge(evalCp, isDark),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              'vs ${widget.game.opponentUsername}',
              style: const TextStyle(fontSize: 16),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
      actions: [
        IconButton(
          icon: const Icon(Icons.settings),
          onPressed: () => _showSettings(context),
          tooltip: 'Board settings',
        ),
        if (kDebugMode) _buildDebugMenu(),
      ],
    );
  }

  PopupMenuButton<String> _buildDebugMenu() {
    return PopupMenuButton<String>(
      icon: const Icon(Icons.more_vert),
      onSelected: (value) => _handleDebugAction(value, _userId),
      itemBuilder: (context) => [
        const PopupMenuItem(
          value: 'clear_analysis',
          child: Row(
            children: [Icon(Icons.delete_outline, size: 20), SizedBox(width: 8), Text('Clear Analysis')],
          ),
        ),
        const PopupMenuItem(
          value: 're_analyze',
          child: Row(
            children: [Icon(Icons.refresh, size: 20), SizedBox(width: 8), Text('Re-analyze')],
          ),
        ),
      ],
    );
  }

  Widget _buildEvalBadge(int? evalCp, bool isDark) {
    String text = '0.0';
    Color bgColor = isDark ? Colors.grey.shade700 : Colors.grey.shade300;
    Color textColor = isDark ? Colors.white : Colors.black87;

    if (evalCp != null) {
      if (evalCp.abs() >= 10000) {
        // Mate score
        final mateIn = ((10000 - evalCp.abs()) / 2).ceil();
        text = evalCp > 0 ? 'M$mateIn' : '-M$mateIn';
        bgColor = evalCp > 0 ? Colors.white : Colors.grey.shade800;
        textColor = evalCp > 0 ? Colors.black87 : Colors.white;
      } else {
        // Centipawn score
        final pawns = evalCp / 100;
        if (pawns > 0) {
          text = '+${pawns.toStringAsFixed(1)}';
          bgColor = Colors.white;
          textColor = Colors.black87;
        } else if (pawns < 0) {
          text = pawns.toStringAsFixed(1);
          bgColor = Colors.grey.shade800;
          textColor = Colors.white;
        }
      }
    }

    return Container(
      width: 50,
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(
          color: isDark ? Colors.grey.shade600 : Colors.grey.shade400,
          width: 1,
        ),
      ),
      child: Text(
        text,
        textAlign: TextAlign.center,
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.bold,
          color: textColor,
        ),
      ),
    );
  }

  void _showSettings(BuildContext context) {
    showBoardSettingsSheet(
      context: context,
      ref: ref,
      onFlipBoard: () {
        setState(() {
          _orientation = _orientation == Side.white ? Side.black : Side.white;
        });
      },
    );
  }

  Widget _buildBody(GameReviewState state, ExplorationState explorationState, double boardSize, bool isDark) {
    if (state.isLoading) return const Center(child: CircularProgressIndicator());

    if (state.isAnalyzing) {
      return AnalyzingView(progress: state.analysisProgress, message: state.analysisMessage);
    }

    if (state.error != null) {
      return ReviewErrorView(
        error: state.error!,
        onRetry: () => ref.read(gameReviewProvider(_userId).notifier).analyzeGame(widget.game),
      );
    }

    if (state.review == null) return const Center(child: Text('No review available'));

    return Column(
      children: [
        AccuracySummary(
          review: state.review!,
          opponentUsername: widget.game.opponentUsername,
          isDark: isDark,
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8.0),
          child: Stack(
            children: [
              ReviewChessboard(
                state: state,
                explorationState: explorationState,
                boardSize: boardSize,
                orientation: _orientation,
                onMove: (move) => _onBoardMove(move, state),
              ),
              if (state.currentMove != null && !explorationState.isExploring)
                ReviewMoveMarker(
                  move: state.currentMove!,
                  boardSize: boardSize,
                  orientation: _orientation,
                ),
            ],
          ),
        ),
        // B3: Reordered - Move history first, then the info panel
        _buildMoveStrip(state, explorationState, isDark),
        Expanded(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // B3: Removed BestMoveHint ("best tap to explore" bar)
                if (explorationState.isExploring)
                  ExplorationBar(explorationState: explorationState, isDark: isDark),
                // B3: MoveInfoPanel (the "nice bar") now comes after move history
                if (state.currentMove != null && !explorationState.isExploring)
                  MoveInfoPanel(move: state.currentMove!, isDark: isDark),
              ],
            ),
          ),
        ),
        _buildNavigationControls(state, explorationState),
        ReviewActionButtons(
          mistakesCount: _getMistakesCount(state),
          isPracticeLoading: _isGeneratingPuzzles,
          onPractice: () => _generateAndNavigateToPuzzles(state),
          onPlayEngine: () => _navigateToPlayVsStockfish(state, explorationState),
        ),
        SizedBox(height: MediaQuery.of(context).padding.bottom + 8),
      ],
    );
  }

  Widget _buildMoveStrip(GameReviewState state, ExplorationState explorationState, bool isDark) {
    return MoveStrip(
      moves: state.review!.moves,
      currentMoveIndex: explorationState.isExploring
          ? (explorationState.originalMoveIndex ?? state.currentMoveIndex)
          : state.currentMoveIndex,
      isDark: isDark,
      onMoveSelected: (index) {
        if (explorationState.isExploring) {
          ref.read(explorationModeProvider.notifier).returnToGame();
        }
        ref.read(gameReviewProvider(_userId).notifier).goToMove(index);
        if (index > 0) _playSoundForMoveIndex(index);
      },
    );
  }

  Widget _buildNavigationControls(GameReviewState state, ExplorationState explorationState) {
    return NavigationControls(
      currentMoveIndex: state.currentMoveIndex,
      totalMoves: state.review?.moves.length ?? 0,
      isPlaying: _isPlaying,
      onPlay: () {
        if (explorationState.isExploring) {
          ref.read(explorationModeProvider.notifier).returnToGame();
        }
        _togglePlayback();
      },
      onFirst: () {
        _stopPlayback();
        if (explorationState.isExploring) ref.read(explorationModeProvider.notifier).returnToGame();
        ref.read(gameReviewProvider(_userId).notifier).goToStart();
      },
      onPrevious: () {
        _stopPlayback();
        if (explorationState.isExploring) {
          ref.read(explorationModeProvider.notifier).undoMove();
        } else {
          final currentIdx = ref.read(gameReviewProvider(_userId)).currentMoveIndex;
          ref.read(gameReviewProvider(_userId).notifier).previousMove();
          if (currentIdx > 1) _playSoundForMoveIndex(currentIdx - 1);
        }
      },
      onNext: () {
        _stopPlayback();
        if (explorationState.isExploring) ref.read(explorationModeProvider.notifier).returnToGame();
        final currentIdx = ref.read(gameReviewProvider(_userId)).currentMoveIndex;
        final totalMoves = ref.read(gameReviewProvider(_userId)).review?.moves.length ?? 0;
        ref.read(gameReviewProvider(_userId).notifier).nextMove();
        if (currentIdx < totalMoves) _playSoundForMoveIndex(currentIdx + 1);
      },
      onLast: () {
        _stopPlayback();
        if (explorationState.isExploring) ref.read(explorationModeProvider.notifier).returnToGame();
        final totalMoves = ref.read(gameReviewProvider(_userId)).review?.moves.length ?? 0;
        ref.read(gameReviewProvider(_userId).notifier).goToEnd();
        if (totalMoves > 0) _playSoundForMoveIndex(totalMoves);
      },
    );
  }

  // Sound helpers
  void _playMoveSound(NormalMove move, String fen) {
    try {
      final position = Chess.fromSetup(Setup.parseFen(fen));
      final san = position.makeSan(move).$2;
      _playSoundFromSan(san);
    } catch (_) {}
  }

  void _playSoundFromSan(String san) {
    ref.read(audioServiceProvider).playMoveWithHaptic(
      isCapture: san.contains('x'),
      isCheck: san.contains('+'),
      isCastle: san == 'O-O' || san == 'O-O-O',
      isCheckmate: san.contains('#'),
    );
  }

  void _playSoundForMoveIndex(int moveIndex) {
    final state = ref.read(gameReviewProvider(_userId));
    if (state.review == null || moveIndex <= 0 || moveIndex > state.review!.moves.length) return;
    _playSoundFromSan(state.review!.moves[moveIndex - 1].san);
  }

  void _onBoardMove(NormalMove move, GameReviewState state) {
    _playMoveSound(move, state.fen);

    String? expectedUci;
    if (state.currentMoveIndex < (state.review?.moves.length ?? 0)) {
      expectedUci = state.review!.moves[state.currentMoveIndex].uci;
    }

    final isExplorationMove = ref.read(explorationModeProvider.notifier).makeMove(
      move,
      expectedUci: expectedUci,
    );

    if (!isExplorationMove && expectedUci != null) {
      ref.read(gameReviewProvider(_userId).notifier).nextMove();
    }
  }

  // Navigation helpers

  /// Get top 3 puzzle-worthy mistakes sorted by severity (highest centipawn loss first)
  List<AnalyzedMove> _getTopMistakes(GameReviewState state) {
    if (state.review == null) return [];

    final mistakes = state.review!.moves
        .where((m) => m.color == widget.game.playerColor)
        .where((m) => m.classification.isPuzzleWorthy)
        .where((m) => m.bestMoveUci != null) // Must have a solution
        .toList();

    // Sort by centipawn loss (most severe first)
    mistakes.sort((a, b) {
      final lossA = a.evalAfter != null && a.evalBefore != null
          ? (a.evalBefore! - a.evalAfter!).abs()
          : 0;
      final lossB = b.evalAfter != null && b.evalBefore != null
          ? (b.evalBefore! - b.evalAfter!).abs()
          : 0;
      return lossB.compareTo(lossA);
    });

    // Return top 3 most severe mistakes
    return mistakes.take(3).toList();
  }

  int _getMistakesCount(GameReviewState state) {
    return _getTopMistakes(state).length;
  }

  /// Auto-generate puzzles in background after analysis completes (without navigation)
  Future<void> _autoGeneratePuzzles(GameReviewState state) async {
    if (state.review == null) return;

    setState(() => _isGeneratingPuzzles = true);

    try {
      // First check if puzzles already exist in database
      final existingPuzzles = await LocalDatabase.getGamePuzzles(state.review!.id);

      if (existingPuzzles.isNotEmpty) {
        // Puzzles already exist, just mark as done
        if (mounted) {
          setState(() => _isGeneratingPuzzles = false);
        }
        return;
      }

      // Extract puzzles using the Review API
      final puzzles = await _extractPuzzlesFromApi(state.review!.id);

      if (!mounted) return;

      if (puzzles.isNotEmpty) {
        await _savePuzzlesToDb(puzzles);
      }

      setState(() => _isGeneratingPuzzles = false);
    } catch (e) {
      debugPrint('Error auto-generating puzzles: $e');
      if (mounted) {
        setState(() => _isGeneratingPuzzles = false);
      }
    }
  }

  Future<void> _generateAndNavigateToPuzzles(GameReviewState state) async {
    if (state.review == null) return;

    setState(() => _isGeneratingPuzzles = true);

    try {
      // First check if puzzles already exist in database
      final existingPuzzles = await LocalDatabase.getGamePuzzles(state.review!.id);

      if (existingPuzzles.isNotEmpty) {
        // Load existing puzzles
        final puzzles = _parsePuzzlesFromDb(existingPuzzles, state);
        if (!mounted) return;
        setState(() => _isGeneratingPuzzles = false);
        _navigateToPractice(puzzles);
        return;
      }

      // Extract puzzles using the Review API
      final puzzles = await _extractPuzzlesFromApi(state.review!.id);

      if (!mounted) return;

      if (puzzles.isEmpty) {
        setState(() => _isGeneratingPuzzles = false);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('No puzzles found in this game')),
        );
        return;
      }

      // Save puzzles to database for consistency
      await _savePuzzlesToDb(puzzles);

      setState(() => _isGeneratingPuzzles = false);
      _navigateToPractice(puzzles);
    } on RateLimitException catch (e) {
      if (mounted) {
        setState(() => _isGeneratingPuzzles = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(e.message)),
        );
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isGeneratingPuzzles = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error extracting puzzles: $e')),
        );
      }
    }
  }

  /// Extract puzzles from the Review API
  Future<List<GamePuzzle>> _extractPuzzlesFromApi(String reviewId) async {
    final result = await ReviewApiService.extractPuzzles(
      pgn: widget.game.pgn,
      playerColor: widget.game.playerColor,
      reviewId: reviewId,
    );

    return result.puzzles.map((extracted) {
      // Determine player color from FEN - the side to move in the puzzle position
      final setup = Setup.parseFen(extracted.fen);
      final puzzlePlayerColor = setup.turn == Side.white ? 'white' : 'black';

      // Create a synthetic AnalyzedMove for the originalMistake reference
      final syntheticMistake = AnalyzedMove(
        id: '${reviewId}_puzzle_${extracted.moveNumber}',
        gameReviewId: reviewId,
        moveNumber: extracted.moveNumber,
        color: extracted.moveNumber % 2 == 0 ? 'white' : 'black',
        fen: extracted.fen,
        san: '',
        uci: extracted.playedMove,
        classification: _typeToClassification(extracted.type),
        bestMove: extracted.bestMove,
        bestMoveUci: extracted.bestMove,
        centipawnLoss: extracted.evaluationSwing.abs().round(),
      );

      return GamePuzzle(
        id: const Uuid().v4(),
        gameReviewId: reviewId,
        fen: extracted.fen,
        playerColor: puzzlePlayerColor,
        solutionUci: extracted.solution,
        solutionSan: [],
        classification: syntheticMistake.classification,
        theme: extracted.themes.isNotEmpty ? extracted.themes.first : 'tactics',
        moveNumber: extracted.moveNumber,
        originalMistake: syntheticMistake,
      );
    }).toList();
  }

  MoveClassification _typeToClassification(String type) {
    return switch (type.toLowerCase()) {
      'mistake' => MoveClassification.mistake,
      'missed_tactic' => MoveClassification.miss,
      'brilliant' => MoveClassification.brilliant,
      'blunder' => MoveClassification.blunder,
      _ => MoveClassification.mistake,
    };
  }

  List<GamePuzzle> _parsePuzzlesFromDb(List<Map<String, dynamic>> dbPuzzles, GameReviewState state) {
    final puzzles = <GamePuzzle>[];
    for (final dbPuzzle in dbPuzzles) {
      // Find the original mistake by move number
      final moveNumber = dbPuzzle['move_number'] as int;
      final originalMistake = state.review!.moves.firstWhere(
        (m) => m.moveNumber == moveNumber,
        orElse: () => state.review!.moves.first,
      );

      // Parse JSON arrays
      final solutionUciStr = dbPuzzle['solution_uci'] as String;
      final solutionSanStr = dbPuzzle['solution_san'] as String;
      final solutionUci = solutionUciStr.split(',');
      final solutionSan = solutionSanStr.split(',');

      puzzles.add(GamePuzzle(
        id: dbPuzzle['id'] as String,
        gameReviewId: dbPuzzle['game_review_id'] as String,
        fen: dbPuzzle['fen'] as String,
        playerColor: dbPuzzle['player_color'] as String,
        solutionUci: solutionUci,
        solutionSan: solutionSan,
        classification: MoveClassificationExtension.fromJson(dbPuzzle['classification'] as String?),
        theme: dbPuzzle['theme'] as String?,
        moveNumber: moveNumber,
        originalMistake: originalMistake,
      ));
    }
    return puzzles;
  }

  Future<void> _savePuzzlesToDb(List<GamePuzzle> puzzles) async {
    final puzzleMaps = puzzles.map((p) => {
      'id': p.id,
      'game_review_id': p.gameReviewId,
      'fen': p.fen,
      'player_color': p.playerColor,
      'solution_uci': p.solutionUci.join(','), // Store as comma-separated
      'solution_san': p.solutionSan.join(','), // Store as comma-separated
      'classification': p.classification.name,
      'theme': p.theme,
      'move_number': p.moveNumber,
      'created_at': DateTime.now().toIso8601String(),
    }).toList();

    await LocalDatabase.saveGamePuzzles(_userId, puzzleMaps);
  }

  void _navigateToPractice(List<GamePuzzle> puzzles) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PracticePuzzlesScreen(
          puzzles: puzzles,
          gameId: widget.game.id,
        ),
      ),
    );
  }

  void _navigateToPlayVsStockfish(GameReviewState state, ExplorationState explorationState) {
    final fen = explorationState.isExploring ? explorationState.fen : state.fen;
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PlayVsStockfishScreen(
          startFen: fen,
          playerColor: widget.game.playerColor == 'white' ? Side.white : Side.black,
        ),
      ),
    );
  }

  Future<void> _handleDebugAction(String action, String userId) async {
    switch (action) {
      case 'clear_analysis':
        await LocalDatabase.deleteGameReviewByGameId(userId, widget.game.id);
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Analysis data cleared')));
          Navigator.pop(context);
        }
        break;
      case 're_analyze':
        await LocalDatabase.deleteGameReviewByGameId(userId, widget.game.id);
        if (mounted) {
          ref.read(gameReviewProvider(userId).notifier).analyzeGame(widget.game);
        }
        break;
    }
  }
}
